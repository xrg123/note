做过的项目主要有两个，一个是广州南站智慧公寓系统，这个系统是为方便广州南站进行人员管理、乘务员健康监控等服务的。此工作主要集中在前端，项目中我们使用了基于Nginx的ZcmIIs服务器。另一个项目是驿书交易系统，此项目是一个包含酒店住宿、景区门票的在线交易系统，主要包括交易交换转让、团购、订房小程序及管理模块这些功能。这个项目我们用了Springboot+Mybatis框架，数据库采用的是MySQL，同时用redis做了缓存。项目中，我们采用Quartz进行任务调度，并使用rabbitMQ进行异步请求。项目的日志系统使用的是logback+slf4j。在此项目中，我的职责是参与并完成用户登录及权限验证部分的工作，完成团购模块的工作并参与部分前端工作。

-----------------------------------------------------------------------------------------------------------------------------------------------------------

用户表：id,电话，用户名，身份证号，昵称，salt,状态（锁定、未锁定）

角色表：id,uid，角色

用户等级表：用户id，等级，积分

用户支付表：用户id，银行卡信息

用户登录后，会生成一个token作为key,用户信息作为value,将其存到redis中，并将token返回到前端。前端进行其他请求时，会将token放在请求头中，从redis中获取

### 1、分布式session

为什么要用分布式session,直接存在tomcat中不就可以了吗

1、如果业务量很大的话，存在tomcat中会增大服务器内存压力

2、采用tomcat集群，每个tomcat节点只能存储自己产生的session,同一个用户访问不同的tomcat会产生不同的session存储在不同tomcat中。如果要进行权限验证的话，会导致在不同tomcat节点中重复验证。

### 2、自定义注解及参数校验

过滤器解决跨域问题

写一个类实现Filter接口，接口中有三个方法，initial（）、destory()及doFilter()方法，在foFilter()方法中写如过滤器。过滤后，执行FilterChain的doFilter()方法

在过滤器中设置响应头参数“Access-Control-Allow-Origin”等解决跨域

=======================================================================================

JSR303参数校验

首先进行导包。

写一个注解类。

实现验证过程。

=======================================================================================

拦截器进行登录及权限验证。

写一个类实现HandlerInterceptor接口，有三个方法preHandle、postHandle、afterCompletion，在preHandle中进行拦截

1、登录验证

获取方法注解，若注解为空，return true放过。若注解不为空，存在AccessToken,从请求头部信息中去除token在redis中进行验证，已登录，放过，未登录，返回错误码，前端跳转到登录页面

2、权限验证

获取注解权限

获取用户权限

进行比对

### 3、自定义异常码及全局异常捕获器

捕获全局异常用ControllerAdvice和ExceptionHandler注解进行

### 4、团购业务

团购项目表：id（时间戳),项目名称,开始时间，结束时间，总金额，成功比例，审核状态（通过，未审核，驳回）

项目详情表：id,项目id,当前完成金额，当前团购人数，当前完成状态（正在进行，完成，失败）

项目进展表：id,项目名称，项目进展，时间

团购订单：订单号（），项目id,项目名称，用户id,用户名，数量，单价，总金额，生成时间，支付状态

订单号：获取时间戳，取年月日，前三个字母代表年月日（年A-Z,月A-L，日A-Z, 0-9)   第5位设置为T

### 5、RabbitMQ

团购平台缓存：

系统初始化会将产品数量同步到缓存中，并设置过期时间为30分钟。









团购平台使用RabbitMQ进行异步下单，提高用户体验。

RabbitMQ:是一个消息代理，用于接受和转发消息。消息流经RabbitMQ,存储在一个队列里，队列是一个很大的消息缓冲区，只受主机内存和磁盘的限制。生产者向消息队列中发送消息，接收者从消息队列中接受消息。消息队列用户在不同应用之间传递消息。

RabbitMQ四种交换机模式：

1、direct模式：发送端的消息发送到指定的消息队列中。

2、topic模式：将不同队列绑定到交换机上，若发送端topic和某个队列匹配，则消息进入该队列 。所以可能不同队列会消费同一个消息

3、fanout模式：即广播模式，发送端的消息发送到不同消息队列中。根topic交换机模式的区别：topic模式的队列有一个匹配的过程，所有队列不一定能都能收到消息。

4、header模式：发送端的消息，只有当消息头匹配时才能入队。

RabbitMQ中，生产者发送的消息首先要交给Exchange交换器，再由交换器将消息路由给队列。Procuder发布的Message进入了Exchange。Exchange通过Routing key与Queue绑定在一起。通过Routing key， RabbitMQ可以得知应该把这个Message放到哪个Queue里。Exchange分发消息时根据类型的不同分发策略有区别，目前共五种类型：direct、topic、fanout、headers、x-delayed-message。

direct。如果Routing key匹配, 那么Message就会被传递到相应的Queue中。

topic。对Routing key进行模式匹配，比如key*可以传递到Routing key为key1、key2、key3的Queue。

fanout。每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。



消息队列好处：解耦、异步、削峰

缺点：系统可用性降低、复杂性提高、一致性问题

RabbitMQ、ActiveMQ、RocketMQ、Kafka优缺点

1、单机吞吐量（单位时间处理消息的速度）：RabbitMQ、ActiveMQ单机吞吐量为万级，两外两个为十万级

2、时效性：RabbitMQ延迟为微秒级，其余几个都是毫秒级

3、消息可靠性：RabbitMQ基本部队是

用RabbitMQ的原因，吞吐量能满足要求，延迟最低，可靠性稳定性比较好，开源，社区活跃度高

如何保证消息队列的高可用：我们项目采用的是单机模式的，还可采用集群模式来部署，保证高可用应该使用镜像集群模式。

如何保证消息不被重复消费：消息队列中要进行的操作是减库存、下订单。由于订单号唯一，所以如果数据库中已经插入后，重复消费只会报错，并不会在数据库中放入脏数据。减库存下订单是在一个事务中进行，所以不用考虑重复消费对减库存的影响。

------------------------------------------------------------------------------------------------------------------------------------------------------

如何保证消息的可靠传输，也就是消息在传递过程中不丢失：数据丢失可能出现在生产者、MQ、消费者中，我们用消息队列是来传递订单信息，如果消息丢失的话，用户重新下单就可，所以没有考虑消息丢失的问题。

=====================================================================================

如果是要传递重要信息的话，防止生产者弄丢消息可用：

1、RabbitMQ提供的事务机制来处理。生产者发送消息前开启RabbitMQ的事务，生产者生产的消息发送给MQ的过程中，若消息没有成功被RabbitMQ接受到，生产者会收到异常报错，此使事务回滚，重试发送消息。若MQ接收到了消息，就可提交事务。但这会使系统吞吐量降低。

2、开启 `confirm` 模式，在生产者那里设置开启 `confirm` 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 `ack` 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 `nack` 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。

=====================================================================================

防止RabbitMQ弄丢消息：

**开启 RabbitMQ 的持久化**，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，**恢复之后会自动读取之前存储的数据**，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，**可能导致少量数据丢失**，但是这个概率较小。

持久化可以跟生产者那边的 `confirm` 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 `ack` 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 `ack`，你也是可以自己重发的。

======================================================================================

消费端弄丢消息：

RabbitMQ 如果丢失了数据，主要是因为你消费的时候，**刚消费到，还没处理，结果进程挂了**，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。

这个时候得用 RabbitMQ 提供的 `ack` 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 `ack`，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 `ack` 一把。这样的话，如果你还没处理完，不就没有 `ack` 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。

















